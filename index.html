<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SixStarCruises- Send Free Postcards</title>
    <link rel="icon" type="ssc_favicon.ico" href="ssc_favicon.ico" />
    <script src="https://www.google.com/recaptcha/api.js" async defer></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js" async></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Caveat:wght@400;700&family=Dancing+Script:wght@400;700&family=Indie+Flower&family=Pacifico&family=Homemade+Apple&family=Gochi+Hand&family=Dawning+of+a+New+Day&display=swap" rel="stylesheet">
    <style>
        
  body {
            font-family: 'Inter', sans-serif;
        }
        /* START: Enforce A5 aspect ratio for previews */
        #final-preview-front-container, #final-preview-back-container {
            aspect-ratio: 210 / 148;
        }
        /* END: Enforce A5 aspect ratio for previews */
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
            padding-top: 0;
            padding-bottom: 0;
        }
        .accordion-content.open {
            max-height: 2000px; /* Increased max-height to prevent clipping */
            padding-top: 1rem;
            padding-bottom: 1rem;
        }
        .accordion-header.open .accordion-icon {
            transform: rotate(180deg);
        }
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 8px; background: #e5e7eb;
            border-radius: 4px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 20px; height: 20px; background: #0E0B3D;
            cursor: pointer; border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px; background: #0E0B3D;
            cursor: pointer; border-radius: 50%;
        }
        /* Masonry Layout Styles */
        .grid-item {
            width: 33.333%;
            padding: 2px; /* Equivalent to gap-1 */
            box-sizing: border-box;
        }
        @media (max-width: 640px) {
            .grid-item {
                width: 50%;
            }
        }
        .grid-item img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="bg-slate-50 text-gray-800 flex flex-col items-center min-h-screen p-4 md:p-8">

    <div class="w-full max-w-2xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-2xl md:text-3xl font-bold" style="color: #b9965b;">Send holiday postcards home now.</h1>
            <p class="text-black mt-2">Upload pics, add a message and we'll post them for you tomorrow. A free service from <a href="https://www.sixstarcruises.co.uk//" target="_blank" class="font-bold hover:underline" style="color: #b9965b;">Six Star Cruises</a>.</p>
        </header>

        <main class="w-full bg-white p-4 sm:p-6 rounded-2xl shadow-xl flex flex-col gap-2">

            <!-- Accordion Section 1: Front Image -->
            <div class="border rounded-lg overflow-hidden">
                <div id="accordion-header-1" class="accordion-header flex justify-between items-center p-2 cursor-pointer bg-slate-50 hover:bg-slate-100">
                     <div class="flex items-center gap-2">
                        <svg id="tick-1" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-500 hidden" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" /></svg>
                        <h3 class="text-sm font-bold text-gray-700">1. Design Front</h3>
                    </div>
                    <svg class="accordion-icon w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div id="accordion-content-1" class="accordion-content px-4">
                    <div id="preview-container" class="relative w-full aspect-[210/148] rounded-lg shadow-[6px_6px_15px_rgba(0,0,0,0.3)] flex items-center justify-center text-center transition-all duration-300 hidden">
                        <canvas id="preview-canvas" class="rounded-lg"></canvas>
                        <div id="image-controls" class="absolute top-2 right-2 flex gap-2 hidden">
                            <button id="delete-image-btn" class="bg-red-500 hover:bg-red-600 text-white p-2 rounded-md w-8 h-8 flex items-center justify-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                </svg>
                            </button>
                        </div>
                        <div id="zoom-controls" class="absolute bottom-2 right-2 flex flex-col gap-1">
                            <button id="zoom-in-btn" class="w-8 h-8 flex items-center justify-center bg-black bg-opacity-50 hover:bg-opacity-75 text-white font-bold rounded-full text-lg">+</button>
                            <button id="zoom-out-btn" class="w-8 h-8 flex items-center justify-center bg-black bg-opacity-50 hover:bg-opacity-75 text-white font-bold rounded-full text-lg">-</button>
                        </div>
                    </div>
                    <div id="image-placeholder" class="flex flex-col items-center justify-center gap-4 py-6 sm:py-10">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>
                        <div class="flex flex-col gap-2">
                            <label for="image-uploader" class="cursor-pointer text-white font-bold py-2 px-4 rounded-lg transition duration-300 shadow-md" style="background-color: #b9965b;">Upload a Pic</label>
                            <button id="show-search-modal-btn" class="text-white font-bold py-2 px-4 rounded-lg transition duration-300 shadow-md" style="background-color: #212529;">Find an Image</button>
                        </div>
                    </div>
                    <input type="file" id="image-uploader" accept="image/*" class="hidden"/>
                    <p id="image-warning" class="text-red-500 text-sm mt-2 hidden"></p>
                </div>
            </div>

             <!-- Accordion Section 2: Text -->
            <div class="border rounded-lg overflow-hidden">
                <div id="accordion-header-2" class="accordion-header flex justify-between items-center p-2 cursor-pointer bg-slate-50 hover:bg-slate-100">
                    <div class="flex items-center gap-2">
                        <svg id="tick-2" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-500 hidden" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" /></svg>
                        <h3 class="text-sm font-bold text-gray-700">2. Add text & emojis to the image</h3>
                    </div>
                    <svg class="accordion-icon w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div id="accordion-content-2" class="accordion-content px-4">
                    <input type="text" id="front-text-input" placeholder="Type here..." class="w-full p-2 bg-slate-50 border border-gray-300 rounded-lg mb-4">
                    <p id="front-text-profanity-warning" class="text-red-500 text-sm mb-2 hidden"></p>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div>
                            <label for="front-font-select" class="block text-sm font-medium text-gray-700 mb-1">Font</label>
                            <select id="front-font-select" class="w-full p-2 bg-slate-50 border border-gray-300 rounded-lg"><option value="'Dancing Script', cursive">Dancing Script</option><option value="'Caveat', cursive">Caveat</option><option value="'Indie Flower', cursive">Indie Flower</option><option value="'Pacifico', cursive">Pacifico</option><option value="'Homemade Apple', cursive">Homemade Apple</option><option value="'Gochi Hand', cursive" selected>Gochi Hand</option><option value="'Dawning of a New Day', cursive">Dawning of a New Day</option></select>
                        </div>
                        <div>
                            <label for="front-color-picker" class="block text-sm font-medium text-gray-700 mb-1">Colour</label>
                            <input type="color" id="front-color-picker" value="#FFFFFF" class="w-full h-10 p-1 bg-white border border-gray-300 rounded-lg cursor-pointer">
                        </div>
                    </div>
                     <button id="no-thanks-text-btn" class="mt-4 w-full bg-slate-200 hover:bg-slate-300 text-slate-700 font-bold py-2 px-4 rounded-lg transition-opacity duration-300">No thanks</button>
                </div>
            </div>

            <!-- Accordion Section 3: Message -->
            <div class="border rounded-lg overflow-hidden">
                <div id="accordion-header-3" class="accordion-header flex justify-between items-center p-2 cursor-pointer bg-slate-50 hover:bg-slate-100">
                     <div class="flex items-center gap-2">
                        <svg id="tick-3" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-500 hidden" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" /></svg>
                        <h3 class="text-sm font-bold text-gray-700">3. Write Message on the other side</h3>
                    </div>
                    <svg class="accordion-icon w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div id="accordion-content-3" class="accordion-content px-4">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div class="flex flex-col h-full">
                            <textarea id="text-input" class="w-full p-3 bg-slate-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 transition duration-200 flex-grow" rows="8"></textarea>
                            <p id="message-warning" class="text-red-500 text-sm mt-2 hidden">Warning: Message is too long.</p>
                            <p id="message-profanity-warning" class="text-red-500 text-sm mt-2 hidden"></p>
                        </div>
                        <div class="flex flex-col space-y-4"><select id="font-select" class="w-full p-3 bg-slate-50 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"><option value="'Dancing Script', cursive">Dancing Script</option><option value="'Caveat', cursive">Caveat</option><option value="'Indie Flower', cursive">Indie Flower</option><option value="'Pacifico', cursive">Pacifico</option><option value="'Homemade Apple', cursive">Homemade Apple</option><option value="'Gochi Hand', cursive" selected>Gochi Hand</option><option value="'Dawning of a New Day', cursive">Dawning of a New Day</option></select><input type="color" id="color-picker" value="#1f2937" class="w-full h-12 p-1 bg-white border border-gray-300 rounded-lg cursor-pointer"><div><label for="font-size-slider" class="block text-sm font-medium text-gray-700 mb-1">Font Size: <span id="font-size-value">18</span>px</label><input type="range" id="font-size-slider" min="16" max="40" value="18"></div><div><label for="font-weight-slider" class="block text-sm font-medium text-gray-700 mb-1">Ink Weight: <span id="font-weight-value">400</span></label><input type="range" id="font-weight-slider" min="100" max="900" step="100" value="400"></div></div>
                    </div>
                </div>
            </div>

            <!-- Accordion Section 4: Address -->
            <div class="border rounded-lg overflow-hidden">
                 <div id="accordion-header-4" class="accordion-header flex justify-between items-center p-2 cursor-pointer bg-slate-50 hover:bg-slate-100">
                    <div class="flex items-center gap-2">
                        <svg id="tick-4" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-500 hidden" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" /></svg>
                        <h3 class="text-sm font-bold text-gray-700">4. Add Address</h3>
                    </div>
                    <svg class="accordion-icon w-5 h-5 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div id="accordion-content-4" class="accordion-content px-4">
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <input type="text" id="address-name" placeholder="Recipient Name" class="p-2 bg-slate-50 border border-gray-300 rounded-lg" required>
                        <input type="text" id="address-line1" placeholder="Address Line 1" class="p-2 bg-slate-50 border border-gray-300 rounded-lg" required>
                        <input type="text" id="address-line2" placeholder="Address Line 2 (Optional)" class="p-2 bg-slate-50 border border-gray-300 rounded-lg">
                        <input type="text" id="address-city" placeholder="City" class="p-2 bg-slate-50 border border-gray-300 rounded-lg" required>
                        <input type="text" id="address-postcode" placeholder="Postcode / ZIP" class="p-2 bg-slate-50 border border-gray-300 rounded-lg" required>
                        <div>
                            <input type="text" id="address-country" value="UK" class="p-2 bg-gray-200 border border-gray-300 rounded-lg w-full" disabled>
                            <p class="text-xs text-gray-500 mt-1">Only available in the United Kingdom</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Accordion Section 5: Preview & Send -->
            <div class="border rounded-lg overflow-hidden">
                <div id="accordion-header-5" class="accordion-header flex justify-between items-center p-2 bg-slate-50">
                    <h3 class="text-sm font-bold text-gray-700">5. Preview & Send</h3>
                </div>
                <div id="accordion-content-5" class="accordion-content px-4">
                    <div class="flex flex-col sm:flex-row gap-4 justify-center">
                        <div class="w-full sm:w-1/2">
                            <h4 class="text-center font-semibold mb-2">Front Preview</h4>
                            <div id="final-preview-front-container" class="aspect-[210/148] bg-white rounded-lg shadow-md relative">
                                <img id="final-preview-front" class="w-full h-full object-cover rounded-lg cursor-pointer">
                            </div>
                        </div>
                        <div class="w-full sm:w-1/2">
                            <h4 class="text-center font-semibold mb-2">Back Preview</h4>
                             <div id="final-preview-back-container" class="aspect-[210/148] bg-white rounded-lg shadow-md relative"><img id="final-preview-back" class="w-full h-full object-cover rounded-lg cursor-pointer"></div>
                        </div>
                    </div>
                    <button id="send-postcard-btn" class="w-full mt-6 text-white font-bold py-3 px-4 rounded-lg transition duration-300 shadow-md flex items-center justify-center gap-2" style="background-color: #212529;"><span class="btn-text">Send Postcard</span></button>
                </div>
            </div>
        </main>
    </div>

    <!-- SENDER DETAILS MODAL -->
     <div id="sender-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50">
        <div id="sender-details-view" class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm flex-col gap-4">
            <div class="flex justify-between items-center">
                <h3 class="text-xl font-bold">Your Details</h3>
                <button id="close-sender-modal-btn">&times;</button>
            </div>
            <input type="text" id="sender-name" placeholder="Enter Name" class="p-2 border rounded-lg mt-4" required>
            <input type="email" id="sender-email" placeholder="Enter Email Address" class="p-2 border rounded-lg mt-2" required>
            <div id="recaptcha-container" class="my-4 flex justify-center"></div>
            <button id="final-send-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center gap-2">
                <span class="btn-text">Send</span>
            </button>
            <p class="text-gray-500 text-center mt-2" style="font-size: 10pt;">We collect this information to prevent abuse. Your details are kept private and are not sold or used for any marketing activity.</p>
        </div>
        <div id="check-email-view" class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm flex-col gap-4 text-center hidden">
             <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-blue-500 mx-auto mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" /></svg>
             <h3 class="text-xl font-bold">Check your email</h3>
             <p class="text-gray-600 mt-2">We've sent a confirmation link to your email address. Please click the link to send your postcard.</p>
        </div>
    </div>

    <!-- PIXABAY SEARCH MODAL -->
    <div id="search-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-2xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-4"><h3 class="text-xl font-bold">Search for an Image</h3><button id="close-search-modal-btn">&times;</button></div>
            <div class="flex flex-col gap-2 mb-4 w-full">
                <input type="text" id="search-input" placeholder="e.g., 'sunny beach'" class="w-full p-2 border rounded-lg">
                <button id="search-btn" class="w-full bg-blue-500 text-white px-4 py-2 rounded-lg flex items-center justify-center gap-2"><span class="btn-text">Search</span></button>
            </div>
            <div id="search-loader" class="hidden justify-center items-center py-10 w-full"><div class="loader"></div></div>
            <div id="search-results" class="flex-grow overflow-y-auto min-h-0"></div>
        </div>
    </div>
    
    <!-- ZOOM MODAL -->
    <div id="zoom-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center p-4 z-50">
        <img id="zoomed-image" src="" class="max-w-[90vw] max-h-[90vh] object-contain">
        <button id="close-zoom-modal-btn" class="absolute top-4 right-4 text-white text-3xl font-bold">&times;</button>
    </div>

    <script defer>
        // --- CONFIGURATION ---
        const config = {
            recaptchaSiteKey: '', // Fetched from server
            pixabayApiKey: '', // Fetched from server
            minImageDimension: 800,
            printDPI: 300,
            a5WidthMM: 210,
            a5HeightMM: 148,
            handleRadius: 8,
            maxFileSizeMB: 4
        };

        // --- APPLICATION STATE ---
        const appState = { 
            uploadedImage: null,
            imageSrcForResend: null,
            imageOffsetX: 0,
            imageOffsetY: 0,
            imageZoom: 1.0,
            messagePlaceholderInterval: null,
            isPortrait: false,
            frontText: {
                text: '',
                x: null,
                y: null,
                font: "'Gochi Hand', cursive",
                size: 32,
                width: 200, 
                color: '#FFFFFF',
                rotation: 0
            }
        };

        // --- DOM ELEMENT REFERENCES ---
        const dom = {
            accordionHeaders: document.querySelectorAll('.accordion-header'),
            imageUploader: document.getElementById('image-uploader'),
            imagePlaceholder: document.getElementById('image-placeholder'),
            previewContainer: document.getElementById('preview-container'),
            imageWarning: document.getElementById('image-warning'),
            imageControls: document.getElementById('image-controls'),
            deleteImageBtn: document.getElementById('delete-image-btn'),
            zoomControls: document.getElementById('zoom-controls'),
            zoomInBtn: document.getElementById('zoom-in-btn'),
            zoomOutBtn: document.getElementById('zoom-out-btn'),
            previewCanvas: {
                el: document.getElementById('preview-canvas'),
            },
            frontText: {
                input: document.getElementById('front-text-input'),
                fontSelect: document.getElementById('front-font-select'),
                colorPicker: document.getElementById('front-color-picker'),
                profanityWarning: document.getElementById('front-text-profanity-warning'),
            },
            textInput: document.getElementById('text-input'),
            fontSelect: document.getElementById('font-select'),
            colorPicker: document.getElementById('color-picker'),
            fontSizeSlider: document.getElementById('font-size-slider'),
            fontSizeValue: document.getElementById('font-size-value'),
            fontWeightSlider: document.getElementById('font-weight-slider'),
            fontWeightValue: document.getElementById('font-weight-value'),
            messageWarning: document.getElementById('message-warning'),
            messageProfanityWarning: document.getElementById('message-profanity-warning'),
            addressInputs: { name: document.getElementById('address-name'), line1: document.getElementById('address-line1'), line2: document.getElementById('address-line2'), city: document.getElementById('address-city'), postcode: document.getElementById('address-postcode'), country: document.getElementById('address-country') },
            finalPreviewFrontContainer: document.getElementById('final-preview-front-container'),
            finalPreviewFront: document.getElementById('final-preview-front'),
            finalPreviewBack: document.getElementById('final-preview-back'),
            sendPostcardBtn: document.getElementById('send-postcard-btn'),
            sender: { 
                modal: document.getElementById('sender-modal'), 
                detailsView: document.getElementById('sender-details-view'),
                checkEmailView: document.getElementById('check-email-view'),
                nameInput: document.getElementById('sender-name'), 
                emailInput: document.getElementById('sender-email'), 
                sendBtn: document.getElementById('final-send-btn'), 
                closeBtn: document.getElementById('close-sender-modal-btn'), 
                recaptchaContainer: document.getElementById('recaptcha-container')
            },
            search: { modal: document.getElementById('search-modal'), showBtn: document.getElementById('show-search-modal-btn'), closeBtn: document.getElementById('close-search-modal-btn'), input: document.getElementById('search-input'), searchBtn: document.getElementById('search-btn'), resultsContainer: document.getElementById('search-results'), loader: document.getElementById('search-loader') },
            zoom: { modal: document.getElementById('zoom-modal'), image: document.getElementById('zoomed-image'), closeBtn: document.getElementById('close-zoom-modal-btn')},
            ticks: {
                one: document.getElementById('tick-1'),
                two: document.getElementById('tick-2'),
                three: document.getElementById('tick-3'),
                four: document.getElementById('tick-4')
            },
            noThanksTextBtn: document.getElementById('no-thanks-text-btn')
        };

        // --- CORE LOGIC ---
        
        async function checkForProfanityAPI(text, warningElement) {
            if (!text.trim()) {
                warningElement.classList.add('hidden');
                return false;
            }
            try {
                const response = await fetch('https://vector.profanity.dev', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: text }),
                });
                if (!response.ok) {
                    console.warn("Profanity check failed, allowing submission.");
                    return false; 
                }
                const result = await response.json();
                if (result.isProfanity) {
                    warningElement.textContent = "Be more friendly - consider revising the text";
                    warningElement.classList.remove('hidden');
                    return true;
                } else {
                    warningElement.classList.add('hidden');
                    return false;
                }
            } catch (error) {
                console.warn("Could not reach profanity API, allowing submission.", error);
                warningElement.classList.add('hidden');
                return false; 
            }
        }
        
        function drawCoverImage(ctx, img, canvasWidth, canvasHeight, offsetX, offsetY, zoom) {
            const canvasAspect = canvasWidth / canvasHeight;
            const imgAspect = img.width / img.height;

            let sWidth, sHeight;

            if (imgAspect > canvasAspect) {
                sHeight = img.height;
                sWidth = sHeight * canvasAspect;
            } else {
                sWidth = img.width;
                sHeight = sWidth / canvasAspect;
            }

            sWidth /= zoom;
            sHeight /= zoom;

            let sx = (img.width - sWidth) / 2;
            let sy = (img.height - sHeight) / 2;

            const panScaleFactor = sWidth / canvasWidth;
            sx -= offsetX * panScaleFactor;
            sy -= offsetY * panScaleFactor;
            
            const maxSx = img.width - sWidth;
            const maxSy = img.height - sHeight;
            sx = Math.max(0, Math.min(sx, maxSx));
            sy = Math.max(0, Math.min(sy, maxSy));

            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, canvasWidth, canvasHeight);
        }

        function drawCleanFrontOnContext(ctx, width, height, scaleFactor) {
            if (appState.uploadedImage) {
                const scaledOffsetX = appState.imageOffsetX * scaleFactor;
                const scaledOffsetY = appState.imageOffsetY * scaleFactor;
                drawCoverImage(ctx, appState.uploadedImage, width, height, scaledOffsetX, scaledOffsetY, appState.imageZoom);
            }
            
            if (appState.frontText.text) {
                const { text, font, size, color, x, y, rotation, width: textWidth } = appState.frontText;
                ctx.save();
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const textX = appState.isPortrait ? x * (height / dom.previewCanvas.el.height) : x * scaleFactor;
                const textY = appState.isPortrait ? y * (width / dom.previewCanvas.el.width) : y * scaleFactor;

                ctx.translate(textX, textY);
                ctx.rotate(rotation * Math.PI / 180);
                drawWrappedText(ctx, text, 0, 0, textWidth * scaleFactor, size * scaleFactor * 1.2, `${size * scaleFactor}px ${font}`);
                ctx.restore();
            }
        }
        
        function drawPreviewCanvas() {
            const canvas = dom.previewCanvas.el;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (appState.uploadedImage) {
                drawCoverImage(ctx, appState.uploadedImage, canvas.width, canvas.height, appState.imageOffsetX, appState.imageOffsetY, appState.imageZoom);
            }

            if (appState.frontText.text) {
                if (appState.frontText.x === null) {
                    appState.frontText.x = canvas.width / 2;
                    appState.frontText.y = canvas.height / 2;
                }

                const { text, font, size, color, x, y, rotation, width: textWidth } = appState.frontText;
                ctx.save();
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.translate(x, y);
                ctx.rotate(rotation * Math.PI / 180);
                drawWrappedText(ctx, text, 0, 0, textWidth, size * 1.2, `${size}px ${font}`);
                ctx.restore();
                
                const metrics = getTextMetrics(ctx);
                if (!metrics) return;
                const handles = getHandlePositions(metrics);

                ctx.save();
                ctx.translate(metrics.x, metrics.y);
                ctx.rotate(appState.frontText.rotation * Math.PI / 180);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(metrics.box.x, metrics.box.y, metrics.box.width, metrics.box.height);
                ctx.restore();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 1;

                Object.values(handles).forEach(handle => {
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, config.handleRadius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                });
            }
        }

        function drawWrappedText(ctx, text, x, y, maxWidth, lineHeight, font) {
            ctx.font = font;
            const words = text.split(' ');
            let line = '';
            const lines = [];

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line);

            const totalHeight = lines.length * lineHeight;
            let currentY = y - (totalHeight / 2) + (lineHeight / 2);

            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i].trim(), x, currentY);
                currentY += lineHeight;
            }
        }


        function getTextMetrics(ctx) {
            const { text, font, size, x, y, width: textWidth } = appState.frontText;
            if (!text) return null;
            ctx.font = `${size}px ${font}`;
            
            const words = text.split(' ');
            let line = '';
            let lines = [];
            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ';
                if (ctx.measureText(testLine).width > textWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line);
            
            const height = lines.length * size * 1.2;
            const box = {
                x: -textWidth / 2,
                y: -height / 2,
                width: textWidth,
                height: height
            };
            return { x, y, box };
        }

        function getHandlePositions(metrics) {
            if (!metrics) return {};
            const { x, y, box } = metrics;
            const rotationRad = appState.frontText.rotation * Math.PI / 180;
            const cos = Math.cos(rotationRad);
            const sin = Math.sin(rotationRad);

            const resizeHandleRelX = box.x + box.width;
            const resizeHandleRelY = box.y + box.height;
            const rotateHandleRelX = box.x + box.width / 2;
            const rotateHandleRelY = box.y - 20;
            const widthHandleRelX = box.x + box.width;
            const widthHandleRelY = box.y + box.height / 2;


            return {
                size: {
                    x: x + (resizeHandleRelX * cos - resizeHandleRelY * sin),
                    y: y + (resizeHandleRelX * sin + resizeHandleRelY * cos)
                },
                rotate: {
                    x: x + (rotateHandleRelX * cos - rotateHandleRelY * sin),
                    y: y + (rotateHandleRelY * sin + rotateHandleRelY * cos)
                },
                 width: {
                    x: x + (widthHandleRelX * cos - widthHandleRelY * sin),
                    y: y + (widthHandleRelY * sin + widthHandleRelY * cos)
                }
            };
        }

        function typePlaceholder(element, text) {
            if (appState.messagePlaceholderInterval) clearInterval(appState.messagePlaceholderInterval);
            let i = 0;
            element.placeholder = ""; 
            appState.messagePlaceholderInterval = setInterval(() => {
                if (i < text.length) {
                    element.placeholder += text.charAt(i++);
                } else {
                    clearInterval(appState.messagePlaceholderInterval);
                }
            }, 80);
        }

        function toggleAccordion(header, forceOpen = null) {
            const content = header.nextElementSibling;
            const isOpen = content.classList.contains('open');

            if (forceOpen === true && !isOpen) {
                content.classList.add('open');
                header.classList.add('open');
            } else if (forceOpen === false && isOpen) {
                content.classList.remove('open');
                header.classList.remove('open');
            } else if (forceOpen === null) {
                content.classList.toggle('open');
                header.classList.toggle('open');
            }
            
            const wasOpened = content.classList.contains('open');
            if (wasOpened) {
                 if (header.id.startsWith('accordion-header-5')) debouncedUpdateAllPreviews();
                 if (header.id.startsWith('accordion-header-3') && dom.textInput.value === '') {
                    typePlaceholder(dom.textInput, "Write your message or copy and paste here..");
                }
            }
        }

        async function resizeImage(base64Str) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = base64Str;
                img.onload = () => {
                    const maxDimension = 2400;
                    let { width, height } = img;

                    if (width > maxDimension || height > maxDimension) {
                        if (width > height) {
                            height = Math.round((height * maxDimension) / width);
                            width = maxDimension;
                        } else {
                            width = Math.round((width * maxDimension) / height);
                            height = maxDimension;
                        }
                    }

                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', 0.8));
                };
                img.onerror = (error) => {
                    console.error("Error loading image for resizing:", error);
                    reject(error);
                };
            });
        }
        
        function updatePostcardLayout() {
            const canvas = dom.previewCanvas.el;
            const container = dom.previewContainer;
            
            container.classList.remove('aspect-[210/148]', 'aspect-[148/210]');

            if (appState.isPortrait) {
                container.classList.add('aspect-[148/210]');
            } else {
                container.classList.add('aspect-[210/148]');
            }

            requestAnimationFrame(() => {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                drawPreviewCanvas();
                debouncedUpdateAllPreviews();
            });
        }

        function resetImagePanAndZoom() {
            appState.imageOffsetX = 0;
            appState.imageOffsetY = 0;
            appState.imageZoom = 1.0;
        }

        async function validateAndSetImage(src) {
             const tempImage = new Image();
             await new Promise((resolve, reject) => { 
                tempImage.crossOrigin = "Anonymous";
                tempImage.onload = resolve; 
                tempImage.onerror = reject; 
                tempImage.src = src; 
            });

            if (tempImage.width < config.minImageDimension || tempImage.height < config.minImageDimension) {
                dom.imageWarning.textContent = `For best quality, please upload an image that is at least ${config.minImageDimension}px on its shortest side.`;
                dom.imageWarning.classList.remove('hidden');
                dom.imageUploader.value = '';
                resetImagePreviews();
            } else {
                dom.imageWarning.classList.add('hidden');
                appState.uploadedImage = tempImage;
                appState.imageSrcForResend = src;
                
                appState.isPortrait = tempImage.height > tempImage.width;
                resetImagePanAndZoom();

                dom.imagePlaceholder.classList.add('hidden');
                dom.previewContainer.classList.remove('hidden');
                dom.imageControls.classList.remove('hidden');
                dom.ticks.one.classList.remove('hidden');
                
                updatePostcardLayout();
            }
        }
        
        function resetImagePreviews() {
            appState.uploadedImage = null;
            appState.imageSrcForResend = null;
            appState.isPortrait = false;
            resetImagePanAndZoom();
            
            // Reset front text when image is deleted
            appState.frontText.text = '';
            appState.frontText.x = null;
            appState.frontText.y = null;
            dom.frontText.input.value = '';
            dom.frontText.profanityWarning.classList.add('hidden');
            dom.ticks.two.classList.add('hidden');
            dom.noThanksTextBtn.classList.remove('opacity-0', 'pointer-events-none');
            
            const container = dom.previewContainer;
            container.classList.add('hidden');
            container.classList.remove('aspect-[148/210]');
            container.classList.add('aspect-[210/148]');
            
            dom.imagePlaceholder.classList.remove('hidden');
            dom.imageControls.classList.add('hidden');
            dom.ticks.one.classList.add('hidden');
            
            dom.finalPreviewFrontContainer.classList.remove('aspect-[148/210]');
            dom.finalPreviewFrontContainer.classList.add('aspect-[210/148]');

            if (dom.finalPreviewFront.src) { URL.revokeObjectURL(dom.finalPreviewFront.src); dom.finalPreviewFront.src = ''; }
            debouncedUpdateAllPreviews();
        }

        async function checkMessageOverflow() {
            await document.fonts.ready;
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            const finalWidthPx = Math.round((config.a5WidthMM / 25.4) * config.printDPI);
            const fontSize = dom.fontSizeSlider.value;
            const fontWeight = dom.fontWeightSlider.value;
            const hiResFontSize = fontSize * (finalWidthPx / 504) * 1.2;
            const fontFamily = dom.fontSelect.value;
            const lineHeight = hiResFontSize * 1.2;
            tempCtx.font = `${fontWeight} ${hiResFontSize}px ${fontFamily}`;
            
            const messageText = dom.textInput.value;
            const lines = messageText.split('\n');
            let totalHeight = 0;
            const messageMaxWidth = (finalWidthPx / 2) - 100;

            lines.forEach(line => {
                const words = line.split(' ');
                let currentLine = '';
                for (let i = 0; i < words.length; i++) {
                    const testLine = currentLine + words[i] + ' ';
                    const metrics = tempCtx.measureText(testLine);
                    if (metrics.width > messageMaxWidth && i > 0) {
                        totalHeight += lineHeight;
                        currentLine = words[i] + ' ';
                    } else {
                        currentLine = testLine;
                    }
                }
                totalHeight += lineHeight;
            });

            const maxTextHeight = Math.round((config.a5HeightMM / 25.4) * config.printDPI) - (hiResFontSize * 1.2) - 50;
            if (totalHeight > maxTextHeight) {
                dom.messageWarning.classList.remove('hidden');
            } else {
                dom.messageWarning.classList.add('hidden');
            }
        }
        
        async function generatePostcardImages({ includeAddressOnImage = true, forPrint = false } = {}) {
            await document.fonts.ready; 

            const MM_TO_INCH = 25.4;
            
            let isFinalPortraitForCanvas = appState.isPortrait;
            // For the UI/email preview, if the image is portrait, we want to render it on a landscape canvas.
            if (!forPrint && appState.isPortrait) {
                isFinalPortraitForCanvas = false;
            }

            const finalWidthPx = Math.round((isFinalPortraitForCanvas ? config.a5HeightMM : config.a5WidthMM) / MM_TO_INCH) * config.printDPI;
            const finalHeightPx = Math.round((isFinalPortraitForCanvas ? config.a5WidthMM : config.a5HeightMM) / MM_TO_INCH) * config.printDPI;

            const frontCanvas = document.createElement('canvas');
            frontCanvas.width = finalWidthPx;
            frontCanvas.height = finalHeightPx;
            const frontCtx = frontCanvas.getContext('2d');
            
            if (appState.uploadedImage) {
                // If this is a preview for a portrait image, rotate the context to draw it landscape.
                if (!forPrint && appState.isPortrait) {
                    frontCtx.save();
                    frontCtx.translate(finalWidthPx / 2, finalHeightPx / 2);
                    frontCtx.rotate(90 * Math.PI / 180);
                    frontCtx.translate(-finalHeightPx / 2, -finalWidthPx / 2); // new center is based on swapped dimensions
                    
                    const scaleFactor = finalHeightPx / dom.previewCanvas.el.height;
                    drawCleanFrontOnContext(frontCtx, finalHeightPx, finalWidthPx, scaleFactor);

                    frontCtx.restore();
                } else { // Original logic for landscape images or forPrint=true
                    const scaleFactor = finalWidthPx / (appState.isPortrait ? dom.previewCanvas.el.height : dom.previewCanvas.el.width);
                    drawCleanFrontOnContext(frontCtx, finalWidthPx, finalHeightPx, scaleFactor);
                }
            } else {
                frontCtx.fillStyle = '#6b7280'; 
                frontCtx.font = '80px Inter';
                frontCtx.textAlign = 'center';
                frontCtx.fillText('Waiting for your masterpiece..', finalWidthPx / 2, finalHeightPx / 2);
            }

            const backFinalWidthPx = Math.round((config.a5WidthMM / MM_TO_INCH) * config.printDPI);
            const backFinalHeightPx = Math.round((config.a5HeightMM / MM_TO_INCH) * config.printDPI);
            
            const backCanvas = document.createElement('canvas');
            backCanvas.width = backFinalWidthPx; backCanvas.height = backFinalHeightPx;
            const backCtx = backCanvas.getContext('2d');
            backCtx.fillStyle = 'white';
            backCtx.fillRect(0, 0, backFinalWidthPx, backFinalHeightPx);
            
            backCtx.strokeStyle = '#e5e7eb';
            backCtx.lineWidth = 5;
            backCtx.beginPath();
            backCtx.moveTo(backFinalWidthPx / 2, 50);
            backCtx.lineTo(backFinalWidthPx / 2, backFinalHeightPx - 50);
            backCtx.stroke();

            backCtx.strokeStyle = '#cccccc';
            backCtx.lineWidth = 5;
            backCtx.setLineDash([15, 15]);
            backCtx.strokeRect(backFinalWidthPx - 300, 50, 250, 250);
            backCtx.setLineDash([]);
            
            const fontSize = dom.fontSizeSlider.value;
            const fontWeight = dom.fontWeightSlider.value;
            const hiResFontSize = fontSize * (backFinalWidthPx / 504) * 1.2;
            const fontFamily = dom.fontSelect.value;
            backCtx.fillStyle = dom.colorPicker.value;
            backCtx.font = `${fontWeight} ${hiResFontSize}px ${fontFamily}`;
            backCtx.textAlign = 'left';
            backCtx.textBaseline = 'top';

            const messageText = dom.textInput.value;
            const lines = messageText.split('\n');
            const messageX = 50;
            let messageY = hiResFontSize * 1.2;
            const messageMaxWidth = (backFinalWidthPx / 2) - 100;
            const lineHeight = hiResFontSize * 1.2;

            lines.forEach(line => {
                const words = line.split(' ');
                let currentLine = '';
                for (let i = 0; i < words.length; i++) {
                    const testLine = currentLine + words[i] + ' ';
                    const metrics = backCtx.measureText(testLine); 
                    if (metrics.width > messageMaxWidth && i > 0) {
                        backCtx.fillText(currentLine, messageX, messageY);
                        messageY += lineHeight;
                        currentLine = words[i] + ' ';
                    } else {
                        currentLine = testLine;
                    }
                }
                backCtx.fillText(currentLine, messageX, messageY);
                messageY += lineHeight;
            });
            
            if (includeAddressOnImage) {
                const hiResAddressFontSize = 12 * (backFinalWidthPx / 504) * 1.2;
                backCtx.fillStyle = '#333';
                backCtx.font = `400 ${hiResAddressFontSize}px Inter`;
                backCtx.textAlign = 'left';
                
                const addressLines = [dom.addressInputs.name.value, dom.addressInputs.line1.value, dom.addressInputs.line2.value, dom.addressInputs.city.value, dom.addressInputs.postcode.value].filter(Boolean);
                const addressBlockHeight = addressLines.length * hiResAddressFontSize * 1.4;
                const addressX = (backFinalWidthPx / 2) + 65; 
                let addressY = (backFinalHeightPx / 2) - (addressBlockHeight / 2);

                addressLines.forEach(line => {
                    backCtx.fillText(line, addressX, addressY);
                    addressY += hiResAddressFontSize * 1.4;
                });
            }
            
            return { frontCanvas, backCanvas };
        }
        async function updateFinalPreviews() {
            const { frontCanvas, backCanvas } = await generatePostcardImages({includeAddressOnImage: true});
            
            frontCanvas.toBlob(blob => {
                if (dom.finalPreviewFront.src) URL.revokeObjectURL(dom.finalPreviewFront.src);
                dom.finalPreviewFront.src = URL.createObjectURL(blob);
            });
             backCanvas.toBlob(blob => {
                if (dom.finalPreviewBack.src) URL.revokeObjectURL(dom.finalPreviewBack.src);
                dom.finalPreviewBack.src = URL.createObjectURL(blob);
            });
        }
        async function handleImageSearch() {
            const query = dom.search.input.value;
            if (!query) return;
            if (config.pixabayApiKey === 'YOUR_PIXABAY_API_KEY') {
                alert('Image search is not available in local preview. Please deploy to Vercel to use this feature.');
                return;
            }

            dom.search.loader.style.display = 'flex';
            dom.search.resultsContainer.innerHTML = '';
            
            try {
                const response = await fetch(`https://pixabay.com/api/?key=${config.pixabayApiKey}&q=${encodeURIComponent(query)}&image_type=photo&per_page=21`);
                if (!response.ok) {
                    throw new Error(`Pixabay API responded with status: ${response.status}`);
                }
                const data = await response.json();
                
                dom.search.resultsContainer.innerHTML = ''; 
                
                if (data.hits && data.hits.length > 0) {
                    data.hits.forEach(photo => {
                        const imgContainer = document.createElement('div');
                        imgContainer.className = 'grid-item';
                        const img = document.createElement('img');
                        img.src = photo.webformatURL;
                        img.alt = photo.tags;

                        img.onload = () => {
                            if (dom.search.resultsContainer.children.length === data.hits.length) {
                                new Masonry(dom.search.resultsContainer, {
                                    itemSelector: '.grid-item',
                                    percentPosition: true
                                });
                            }
                        };

                        img.addEventListener('click', async () => {
                            const fullImageResponse = await fetch(photo.largeImageURL);
                            const imageBlob = await fullImageResponse.blob();
                            
                            const reader = new FileReader();
                            reader.onloadend = () => {
                                const base64data = reader.result;
                                validateAndSetImage(base64data);
                            };
                            reader.readAsDataURL(imageBlob);

                            dom.search.modal.style.display = 'none';
                        });
                        imgContainer.appendChild(img);
                        dom.search.resultsContainer.appendChild(imgContainer);
                    });
                } else {
                    dom.search.resultsContainer.innerHTML = `<p class="text-gray-500 col-span-full text-center">No images found for "${query}".</p>`;
                }
            } catch (error) {
                console.error("Error fetching images from Pixabay:", error);
                dom.search.resultsContainer.innerHTML = `<p class="text-red-500 col-span-full text-center">Failed to load images. Please try again later.</p>`;
            } finally {
                dom.search.loader.style.display = 'none';
            }
        }
        async function handleSendPostcard() {
            const requiredAddressFields = [dom.addressInputs.name, dom.addressInputs.line1, dom.addressInputs.city, dom.addressInputs.postcode];
            const allValid = requiredAddressFields.every(input => input.value.trim() !== '');

            if (!allValid) {
                alert('Please fill in all required recipient address fields before sending.');
                const firstEmpty = requiredAddressFields.find(input => input.value.trim() === '');
                if (firstEmpty) {
                    toggleAccordion(document.getElementById('accordion-header-3'), true);
                    firstEmpty.focus();
                }
                return;
            }
            
            const frontIsProfane = await checkForProfanityAPI(dom.frontText.input.value, dom.frontText.profanityWarning);
            const backIsProfane = await checkForProfanityAPI(dom.textInput.value, dom.messageProfanityWarning);

            if (frontIsProfane || backIsProfane) {
                alert("Be more friendly - consider revising the text");
                return;
            }

            dom.sender.modal.style.display = 'flex';
            dom.sender.nameInput.value = localStorage.getItem('senderName') || '';
            dom.sender.emailInput.value = localStorage.getItem('senderEmail') || '';
            grecaptcha.render(dom.sender.recaptchaContainer, { 'sitekey' : config.recaptchaSiteKey });
        }
        async function handleFinalSend() {
            const senderName = dom.sender.nameInput.value;
            const senderEmail = dom.sender.emailInput.value;
            const recaptchaToken = grecaptcha.getResponse();
        
            if (!senderName.trim() || !senderEmail.trim()) {
                alert('Please enter your name and email address.');
                return;
            }
             if (!recaptchaToken) {
                alert('Please complete the reCAPTCHA verification.');
                return;
            }
        
            localStorage.setItem('senderName', senderName);
            localStorage.setItem('senderEmail', senderEmail);
        
            const btnText = dom.sender.sendBtn.querySelector('.btn-text');
            btnText.style.display = 'none';
            const loader = document.createElement('div');
            loader.className = 'loader';
            dom.sender.sendBtn.prepend(loader);
            dom.sender.sendBtn.disabled = true;
        
            try {
                // Generate high-resolution images for printing
                const { frontCanvas, backCanvas: backCanvasForPrint } = await generatePostcardImages({ includeAddressOnImage: false, forPrint: true });
                const { backCanvas: highResBackCanvasForEmail } = await generatePostcardImages({ includeAddressOnImage: true });

                // Create a correctly rotated (if needed) high-res version of the front for email
                const highResEmailFrontCanvas = document.createElement('canvas');
                const MM_TO_INCH = 25.4;
                const emailWidthPx = Math.round((config.a5WidthMM / MM_TO_INCH) * config.printDPI);
                const emailHeightPx = Math.round((config.a5HeightMM / MM_TO_INCH) * config.printDPI);

                highResEmailFrontCanvas.width = emailWidthPx;
                highResEmailFrontCanvas.height = emailHeightPx;
                const emailCtx = highResEmailFrontCanvas.getContext('2d');
                if (appState.isPortrait) {
                    emailCtx.save();
                    emailCtx.translate(emailWidthPx / 2, emailHeightPx / 2);
                    emailCtx.rotate(90 * Math.PI / 180);
                    // --- START: FIX for black bar ---
                    // The arguments are swapped to correctly center the image on a rotated canvas.
                    // The new X-offset is based on the image's height, and the new Y-offset is based on its width.
                    emailCtx.drawImage(frontCanvas, -frontCanvas.height / 2, -frontCanvas.width / 2);
                    // --- END: FIX for black bar ---
                    emailCtx.restore();
                } else {
                    emailCtx.drawImage(frontCanvas, 0, 0);
                }

                // --- START: Create LOW-RESOLUTION versions for email ---
                const createLowResCanvas = (sourceCanvas, maxWidth = 800) => {
                    const scale = maxWidth / sourceCanvas.width;
                    const newWidth = sourceCanvas.width * scale;
                    const newHeight = sourceCanvas.height * scale;
                    const lowResCanvas = document.createElement('canvas');
                    lowResCanvas.width = newWidth;
                    lowResCanvas.height = newHeight;
                    const ctx = lowResCanvas.getContext('2d');
                    ctx.drawImage(sourceCanvas, 0, 0, newWidth, newHeight);
                    return lowResCanvas;
                };

                const lowResFrontCanvasForEmail = createLowResCanvas(highResEmailFrontCanvas);
                const lowResBackCanvasForEmail = createLowResCanvas(highResBackCanvasForEmail);
                // --- END: Create LOW-RESOLUTION versions for email ---

                // Create blobs from all image versions
                const frontBlob = await new Promise(resolve => frontCanvas.toBlob(resolve, 'image/jpeg', 0.9));
                const frontBlobForEmail = await new Promise(resolve => lowResFrontCanvasForEmail.toBlob(resolve, 'image/jpeg', 0.8));
                const backBlobForPrint = await new Promise(resolve => backCanvasForPrint.toBlob(resolve, 'image/jpeg', 0.9));
                const backBlobForEmail = await new Promise(resolve => lowResBackCanvasForEmail.toBlob(resolve, 'image/jpeg', 0.8));
                
                const sanitizedEmail = senderEmail.replace(/[^a-z0-9]/gi, '-');
                const sanitizedName = senderName.replace(/[^a-z0-9]/gi, '-');
                const sanitizedPostcode = dom.addressInputs.postcode.value.replace(/[^a-z0-9]/gi, '-');
                const timestamp = Date.now();

                const frontFilename = `${sanitizedEmail}-${sanitizedName}-${sanitizedPostcode}-front-${timestamp}.jpg`;
                const frontEmailFilename = `${sanitizedEmail}-${sanitizedName}-${sanitizedPostcode}-front-email-${timestamp}.jpg`;
                const backPrintFilename = `${sanitizedEmail}-${sanitizedName}-${sanitizedPostcode}-back-print-${timestamp}.jpg`;
                const backEmailFilename = `${sanitizedEmail}-${sanitizedName}-${sanitizedPostcode}-back-email-${timestamp}.jpg`;

                // --- START: Hybrid upload for optimized performance and reliability ---
                const uploadAndGetData = async (filename, blob) => {
                    const response = await fetch(`/api/upload?filename=${filename}`, { method: 'POST', body: blob });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Failed to upload ${filename}. Server responded with ${response.status}: ${errorText}`);
                    }
                    return response.json();
                };

                // Step 1: Upload small email images in parallel.
                const [frontEmailBlobData, backEmailBlobData] = await Promise.all([
                    uploadAndGetData(frontEmailFilename, frontBlobForEmail),
                    uploadAndGetData(backEmailFilename, backBlobForEmail)
                ]);

                // Step 2: Upload large print images serially.
                const frontBlobData = await uploadAndGetData(frontFilename, frontBlob);
                const backPrintBlobData = await uploadAndGetData(backPrintFilename, backBlobForPrint);
                // --- END: Hybrid upload for optimized performance and reliability ---

                const recipient = {};
                for (const key in dom.addressInputs) {
                    recipient[key] = dom.addressInputs[key].value.trim();
                }
                
                const resendData = {
                    imageSrc: appState.imageSrcForResend,
                    isPortrait: appState.isPortrait,
                    frontText: appState.frontText,
                    message: {
                        text: dom.textInput.value,
                        font: dom.fontSelect.value,
                        color: dom.colorPicker.value,
                        size: dom.fontSizeSlider.value,
                        weight: dom.fontWeightSlider.value
                    }
                };
                localStorage.setItem('lastPostcardDesign', JSON.stringify(resendData));

                const postcardData = {
                    sender: { name: senderName, email: senderEmail },
                    recipient: recipient,
                    frontImageUrl: frontBlobData.url,
                    frontImageUrlForEmail: frontEmailBlobData.url,
                    backImageUrl: backPrintBlobData.url, 
                    backImageUrlWithAddress: backEmailBlobData.url,
                    recaptchaToken: recaptchaToken
                };
                
                const verificationResponse = await fetch('/api/request-verification', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ postcardData })
                });

                if (!verificationResponse.ok) {
                    throw new Error('Failed to send verification email.');
                }
                
                dom.sender.detailsView.style.display = 'none';
                dom.sender.checkEmailView.style.display = 'flex';
        
            } catch (error) {
                console.error('An error occurred during the final send process:', error);

                // --- START: Improved Error Handling ---
                let userMessage = 'There was a problem sending your postcard. Please try again later.';
                // Try to parse a more specific error message from the server response
                if (error.message.includes('Failed to upload')) {
                     userMessage = `There was a problem uploading your image. This can happen on an unstable connection. Please try again.`;
                } else if (error.message.includes('verification email')) {
                    userMessage = `Could not send the verification email. The service may be temporarily busy. Please try again in a few moments.`;
                }

                alert(userMessage);
                // --- END: Improved Error Handling ---

                btnText.style.display = 'inline';
                loader.remove();
                dom.sender.sendBtn.disabled = false;
                grecaptcha.reset();
            }
        }

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        const debouncedUpdateAllPreviews = debounce(updateFinalPreviews, 300);
        const debouncedProfanityCheck = debounce(checkForProfanityAPI, 500);

        async function fetchConfig() {
            try {
                const response = await fetch('/api/config');
                if (!response.ok) {
                    throw new Error(`Server responded with ${response.status}`);
                }
                const serverConfig = await response.json();
                config.recaptchaSiteKey = serverConfig.recaptchaSiteKey;
                config.pixabayApiKey = serverConfig.pixabayApiKey;
            } catch (error) {
                console.warn(`Could not fetch server configuration: ${error.message}. This is expected in a local or preview environment. Ensure environment variables are set correctly on your Vercel deployment.`);
                config.recaptchaSiteKey = '6LeIxAcpAAAAAApp-c-tM8_i21013-10203040';
                config.pixabayApiKey = 'YOUR_PIXABAY_API_KEY';
            }
        }
        
        async function initialize() {
            await fetchConfig();

            if (!config.recaptchaSiteKey) {
                 console.error("reCAPTCHA Site Key not loaded. Halting initialization.");
                 alert("Application is not configured correctly. Please contact the site owner.");
                return; 
            }
            
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('sendAgain') === 'true') {
                const lastDesign = JSON.parse(localStorage.getItem('lastPostcardDesign'));
                if (lastDesign) {
                    dom.frontText.input.value = lastDesign.frontText.text;
                    dom.textInput.value = lastDesign.message.text;
                    dom.fontSelect.value = lastDesign.message.font;
                    dom.colorPicker.value = lastDesign.message.color;
                    dom.fontSizeSlider.value = lastDesign.message.size;
                    dom.fontSizeValue.textContent = lastDesign.message.size;
                    dom.fontWeightSlider.value = lastDesign.message.weight;
                    dom.fontWeightValue.textContent = lastDesign.message.weight;

                    appState.frontText = lastDesign.frontText;
                    appState.isPortrait = lastDesign.isPortrait || false;
                    
                    validateAndSetImage(lastDesign.imageSrc);

                    toggleAccordion(document.getElementById('accordion-header-3'), true);
                    dom.addressInputs.name.focus();
                }
            }

            dom.accordionHeaders.forEach(header => {
                if (header.id !== 'accordion-header-5') {
                    header.addEventListener('click', () => toggleAccordion(header, null));
                }
            });
            dom.imageUploader.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                event.target.value = '';

                const reader = new FileReader();
                reader.onload = async (e) => {
                    let imageDataUrl = e.target.result;
                    if (file.size > config.maxFileSizeMB * 1024 * 1024) {
                        imageDataUrl = await resizeImage(imageDataUrl);
                    }
                    validateAndSetImage(imageDataUrl);
                };
                reader.readAsDataURL(file);
            });
            dom.deleteImageBtn.addEventListener('click', resetImagePreviews);
            
            dom.zoomInBtn.addEventListener('click', () => {
                appState.imageZoom += 0.1;
                drawPreviewCanvas();
                debouncedUpdateAllPreviews();
            });
             dom.zoomOutBtn.addEventListener('click', () => {
                appState.imageZoom = Math.max(1.0, appState.imageZoom - 0.1);
                drawPreviewCanvas();
                debouncedUpdateAllPreviews();
            });


            Object.values(dom.frontText).forEach(el => {
                if (el.tagName === 'INPUT' || el.tagName === 'SELECT') {
                    el.addEventListener('input', () => {
                        const wasEmpty = !appState.frontText.text;
                        appState.frontText.text = dom.frontText.input.value;
                        appState.frontText.font = dom.frontText.fontSelect.value;
                        appState.frontText.color = dom.frontText.colorPicker.value;
                        
                        if(dom.frontText.input.value.trim() !== '') {
                            dom.ticks.two.classList.remove('hidden');
                             dom.noThanksTextBtn.classList.add('opacity-0', 'pointer-events-none');
                        } else {
                            dom.ticks.two.classList.add('hidden');
                             dom.noThanksTextBtn.classList.remove('opacity-0', 'pointer-events-none');
                        }
                        
                        if (wasEmpty && appState.frontText.text && dom.previewCanvas.el.width > 0) {
                           appState.frontText.x = dom.previewCanvas.el.width / 2;
                           appState.frontText.y = dom.previewCanvas.el.height / 2;
                        }
                        
                        debouncedProfanityCheck(appState.frontText.text, dom.frontText.profanityWarning);
                        drawPreviewCanvas();
                        debouncedUpdateAllPreviews();
                    });
                }
            });

            dom.noThanksTextBtn.addEventListener('click', () => {
                dom.ticks.two.classList.remove('hidden');
                toggleAccordion(document.getElementById('accordion-header-2'), false);
                toggleAccordion(document.getElementById('accordion-header-3'), true);
            });

            let interactionMode = 'none';
            let startState = {};
            const canvas = dom.previewCanvas.el;
            const ctx = canvas.getContext('2d');
            
            const handleInteractionStart = (e) => {
                if (e.type === 'touchstart') e.preventDefault();
                if (!appState.uploadedImage) return;

                const rect = canvas.getBoundingClientRect();
                const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                const mouseX = clientX - rect.left;
                const mouseY = clientY - rect.top;
                
                let isOverText = false;
                if (appState.frontText.text) {
                    const metrics = getTextMetrics(ctx);
                    if (metrics && metrics.x !== null) {
                        const handles = getHandlePositions(metrics);

                        const distToResize = Math.hypot(mouseX - handles.size.x, mouseY - handles.size.y);
                        const distToRotate = Math.hypot(mouseX - handles.rotate.x, mouseY - handles.rotate.y);
                        const distToWidth = Math.hypot(mouseX - handles.width.x, mouseY - handles.width.y);
                        
                        const dx = mouseX - metrics.x;
                        const dy = mouseY - metrics.y;
                        const rotationRad = -appState.frontText.rotation * Math.PI / 180;
                        const cos = Math.cos(rotationRad);
                        const sin = Math.sin(rotationRad);
                        const transformedMouseX = dx * cos - dy * sin;
                        const transformedMouseY = dx * sin + dy * cos;
                        
                        const box = metrics.box;
                        const isOverBody = (
                            transformedMouseX >= box.x && transformedMouseX <= box.x + box.width &&
                            transformedMouseY >= box.y && transformedMouseY <= box.y + box.height
                        );
                        
                        if (distToResize <= config.handleRadius) {
                            interactionMode = 'resizing';
                            isOverText = true;
                        } else if (distToRotate <= config.handleRadius) {
                            interactionMode = 'rotating';
                            isOverText = true;
                        } else if (distToWidth <= config.handleRadius) {
                            interactionMode = 'resizingWidth';
                            isOverText = true;
                        } else if (isOverBody) {
                            interactionMode = 'draggingText';
                            isOverText = true;
                        }
                    }
                }

                if (!isOverText) {
                    interactionMode = 'draggingImage';
                }

                startState = {
                    mouseX, mouseY,
                    ...appState.frontText,
                    imageOffsetX: appState.imageOffsetX,
                    imageOffsetY: appState.imageOffsetY,
                    startAngle: Math.atan2(mouseY - appState.frontText.y, mouseX - appState.frontText.x),
                    startDist: Math.hypot(mouseX - appState.frontText.x, mouseY - appState.frontText.y),
                };
            };

            const handleInteractionMove = (e) => {
                if (e.type === 'touchmove') e.preventDefault();
                if (interactionMode === 'none') return;
                
                const rect = canvas.getBoundingClientRect();
                const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                const mouseX = clientX - rect.left;
                const mouseY = clientY - rect.top;

                if (interactionMode === 'draggingText') {
                    canvas.style.cursor = 'move';
                    appState.frontText.x = startState.x + (mouseX - startState.mouseX);
                    appState.frontText.y = startState.y + (mouseY - startState.mouseY);
                } else if (interactionMode === 'rotating') {
                    canvas.style.cursor = 'grabbing';
                    const currentAngle = Math.atan2(mouseY - startState.y, mouseX - startState.x);
                    const angleDiff = currentAngle - startState.startAngle;
                    appState.frontText.rotation = startState.rotation + (angleDiff * 180 / Math.PI);
                } else if (interactionMode === 'resizing') {
                    canvas.style.cursor = 'se-resize';
                    const currentDist = Math.hypot(mouseX - startState.x, mouseY - startState.y);
                    const scaleFactor = currentDist / startState.startDist;
                    appState.frontText.size = Math.max(8, startState.size * scaleFactor);
                } else if (interactionMode === 'resizingWidth') {
                    canvas.style.cursor = 'ew-resize';
                    const rotationRad = -startState.rotation * Math.PI / 180;
                    const cos = Math.cos(rotationRad);
                    const sin = Math.sin(rotationRad);
                    const dx = mouseX - startState.mouseX;
                    const dy = mouseY - startState.mouseY;
                    const projectedDx = dx * cos - dy * sin;
                    appState.frontText.width = Math.max(20, startState.width + (projectedDx * 2));
                } else if (interactionMode === 'draggingImage') {
                    canvas.style.cursor = 'grabbing';
                    const dx = mouseX - startState.mouseX;
                    const dy = mouseY - startState.mouseY;
                    appState.imageOffsetX = startState.imageOffsetX + dx;
                    appState.imageOffsetY = startState.imageOffsetY + dy;
                }
                
                drawPreviewCanvas();
            };

            const handleInteractionEnd = () => {
                if (interactionMode !== 'none') {
                    interactionMode = 'none';
                    canvas.style.cursor = 'default';
                    debouncedUpdateAllPreviews();
                }
            };
            
            canvas.addEventListener('mousedown', handleInteractionStart);
            canvas.addEventListener('mousemove', handleInteractionMove);
            document.addEventListener('mouseup', handleInteractionEnd);
            canvas.addEventListener('touchstart', handleInteractionStart);
            canvas.addEventListener('touchmove', handleInteractionMove);
            canvas.addEventListener('touchend', handleInteractionEnd);
            
            let messageTypingTimer;
            dom.textInput.addEventListener('input', () => {
                clearTimeout(messageTypingTimer);
                messageTypingTimer = setTimeout(() => {
                    if (dom.textInput.value.trim() !== '') {
                        dom.ticks.three.classList.remove('hidden');
                    } else {
                        dom.ticks.three.classList.add('hidden');
                    }
                }, 3000);
            });

            const addressFields = [dom.addressInputs.name, dom.addressInputs.line1, dom.addressInputs.city, dom.addressInputs.postcode];
            addressFields.forEach(field => {
                field.addEventListener('input', () => {
                    const allFilled = addressFields.every(f => f.value.trim() !== '');
                    if (allFilled) {
                        dom.ticks.four.classList.remove('hidden');
                    } else {
                        dom.ticks.four.classList.add('hidden');
                    }
                });
            });

            const messageControls = [dom.textInput, dom.fontSelect, dom.fontSizeSlider, dom.fontWeightSlider];
            messageControls.forEach(el => {
                el.addEventListener('input', () => {
                    if (el.id === 'font-size-slider') dom.fontSizeValue.textContent = el.value;
                    if (el.id === 'font-weight-slider') dom.fontWeightValue.textContent = el.value;
                    checkMessageOverflow();
                    debouncedProfanityCheck(dom.textInput.value, dom.messageProfanityWarning);
                    debouncedUpdateAllPreviews();
                });
            });

            const otherBackControls = [dom.colorPicker, ...Object.values(dom.addressInputs)];
            otherBackControls.forEach(el => {
                el.addEventListener('input', () => {
                    debouncedUpdateAllPreviews();
                });
            });

            dom.search.showBtn.addEventListener('click', () => dom.search.modal.style.display = 'flex');
            dom.search.closeBtn.addEventListener('click', () => dom.search.modal.style.display = 'none');
            dom.search.searchBtn.addEventListener('click', handleImageSearch);
            dom.search.input.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleImageSearch(); });
            dom.sendPostcardBtn.addEventListener('click', handleSendPostcard);
            dom.sender.sendBtn.addEventListener('click', handleFinalSend);
            dom.sender.closeBtn.addEventListener('click', () => dom.sender.modal.style.display = 'none');
            
            dom.finalPreviewFront.addEventListener('click', () => { if (dom.finalPreviewFront.src) { dom.zoom.image.src = dom.finalPreviewFront.src; dom.zoom.modal.style.display = 'flex'; } });
            dom.finalPreviewBack.addEventListener('click', () => { if (dom.finalPreviewBack.src) { dom.zoom.image.src = dom.finalPreviewBack.src; dom.zoom.modal.style.display = 'flex'; } });
            dom.zoom.closeBtn.addEventListener('click', () => dom.zoom.modal.style.display = 'none');
            
            toggleAccordion(document.getElementById('accordion-header-5'), true);
            toggleAccordion(document.getElementById('accordion-header-1'), true);
        }

        initialize();
    </script>
</body>
</html>